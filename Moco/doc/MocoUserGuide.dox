namespace OpenSim {
/** @mainpage

OpenSim Moco is a software package for solving optimal control problems for
musculoskeletal systems modeled in OpenSim.
The package has Python, MATLAB, and XML (command-line) interfaces; the core
library is written in C++. Here are some problems you can solve with Moco:

1. Solve for the muscle activity that tracks a known motion.
2. Solve for a new motion that optimizes some cost functional.
3. Solve for mass properties that minimize residual "hand of God" forces.

The optimal control problems are solved using the direct collocation method.
Learning about direct collocation is beyond the scope of this documentation. See
the following references:

  - TODO Matt Kelly's paper.

Moco can solve specific classes of problems, such as tracking, TODO, and
also has a generic interface for solving custom optimal control problems.

@note Solving a custom optimal control problem with direct collocation is not
easy, and requires significant tuning of the direct collocation method's
settings. Use the more specific interfaces if possible; and only create a custom
problem as a last resort.

Parts of the documentation:
  - @ref userguide



@page userguide User Guide

@tableofcontents

TODO

MocoFramework
MocoTrack

HELLO

@section Example

TODO

The interface to Moco starts with the MocoTool. The MocoTool contains a
MocoProblem and a MocoSolver.

  - MocoProblem: describes the variables, dynamics, constraints, and cost
      functional of the optimal control problem.
  - MocoSolver: solves the MocoProblem using direct collocation.


@section Workflow

When building a MocoTool programmatically (e.g., in C++), the workflow is as
follows:

1. Build the MocoProblem (set the model, constraints, etc.).
2. Call MocoTool::initTropterSolver() (or MocoTool::initCasADiSolver()), which
   returns a reference to a MocoSolver.
3. Edit the settings of the MocoSolver (returned by initSolver()).
4. Call MocoTool::solve(). This returns the MocoSolution.
5. (Optional) Postprocess the solution, perhaps using MocoTool::visualize().

After calling MocoTool::solve(), you can edit the MocoProblem and/or the
MocoSolver and call MocoTool::solve() again, if you wish.


@section problem MocoProblem

A MocoProblem contains multiple phases.

TODO describe bounds (set automatically based on the model).

    ///     The bounds on this state variable over the entire phase. If
    ///     default-constructed (`{}`), and the state is *not* a coordinate
    ///     value, then no bounds are applied. If default-constructed, the state
    ///     *is* a coordinate value and the coordinate's **clamped** property is
    ///     true, then the bounds are set to the coordinate's **range** (see
    ///     Coordinate::clamped and Coordinate::range). (TODO)

@subsection costfunctional Defining the cost functional

See @ref mococost for more information.

@section solver MocoSolver

A MocoSolver attempts to use an optimal control method to solve the MocoProblem,
and exposes the settings that you can use to

@subsection tropter MocoTropterSolver

@par Dynamics mode: implicit

When using the implicit dynamics mode, the differential equations for multibody
dynamics are expressed as implicit differential equations. That is, they are
in the form \f$ 0 = f(x, \dot{x}) \f$ rather than \f$ \dot{x} = f(x) \f$.

The following are not currently supported with implicit dynamics:

1. Auxiliary dynamics (e.g., activation and fiber dynamics).
2. Acceleration-level quantities (e.g., MocoJointReactionNormCost).
3. Kinematic constraints.


@subsection kincon Kinematic constraints

Moco supports enforcing OpenSim kinematic constraints in optimal control 
problems. When the MocoTropterSolver is initialized, any kinematic constraints 
enabled in the model are automatically detected, and additional information
about each constraint is stored. This information includes the number of scalar
path constraints (including derivatives if they exist), the scalar constraint 
kinematic levels (i.e. holonomic, non-holonomic, or acceleration), and the 
number of Lagrange multipliers that are added to the problem to enforce the
constraints. 

MocoTropterSolver has options if the user desires to enforce kinematic 
constraint derivatives or minimize Lagrange multipliers in the problem.

\code{.cpp}
MocoTropterSolver& solver = moco.initTropterSolver();
ms.set_enforce_constraint_derivatives(true);
ms.set_lagrange_multiplier_weight(10);
\endcode

If constraint derivatives are enforced, velocity correction variables are added
to the problem according to the method described in Posa, Kuindersma, and
Tedrake, 2016, "Optimization and stabilization of trajectories for constrained
dynamical systems." It is also possible to modify the default bounds on these 
velocity correction variables:

\code{.cpp}
// Default bounds: [-0.1, 0.1]
ms.set_velocity_correction_bounds({-0.25, 0.25});
\endcode

If constraint derivatives are not enforced or if the multibody constraint 
Jacobian is rank-deficient, it is recommended that the Lagrange multiplier 
minimization term is added to the problem to provide impose uniqueness for 
these variables.

@subsection preskin Prescribed kinematics and MocoInverse

You may wish to solve a problem in which you prescribe known kinematics for all
degrees of freedom and optimize only auxiliary dynamics or actuator
behavior. This allows you to remove the multibody dynamics from the optimization
problem, which makes the problem more tractable. This is called a **muscle
redundancy problem** if you are solving for muscle behavior that could
have generated an observed motion; Static Optimization and Computed Muscle Control
are methods for solving the muscle redundancy problem.
In Moco, you can use the MocoInverse tool to solve optimization problems in
which kinematics are known, including the muscle redundancy problem.

Simbody provides two mechanisms for prescribing the value of a coordinate:
adding a constraint with SimTK::Constraint::PrescribedMotion (see
Coordinate's prescribed and prescribed_function properties), and removing a
degree of freedom using SimTK::Motion. The former leads to a bigger system of
equations (and does not avoid multibody dynamics), while the latter results in a
smaller system of equations. In Moco, we use the PositionMotion component to
prescribe the motion of all degrees of freedom using spline functions, as this
leads to a more tractable direct collocation problem that often converges
reliably and in far less time than a problem containing multibody dynamics.

The MocoInverse tool adds a PrescribedMotion component to your model, with
splines created from a kinematics data file that you provide.

For an unconstrained system, the equations of motion are as follows:

\f[
M \dot{u} + f_{\mathrm{bias}} + \lambda_m = f_{\mathrm{app}}
\f]

The Lagrange multipliers \f$ \lambda_m \f$ are the mobility forces required for
the system to follow the prescribed kinematics. In our case, we do not want any
ficticious forces generated, and so we require that \f$\lambda_m = 0\f$. Note
that the only unknown in this equation is \f$ f_{\mathrm{app}} \f$; the other
quantities are known because they only depend on kinematics.


@subsubsection preskinconstr Prescribed kinematics with kinematic constraints

Prescribing kinematics is more complicated if the system contains kinematic
constraints (e.g., weld constraints, point-on-line constraints, etc.). The
equations of motion are

\f[
M \dot{u} + f_{\mathrm{bias}} + \lambda_m + G^T \lambda_c = f_{\mathrm{app}}
\f]

\f$ G \f$ is the kinematic constraint Jacobian and \f$ \lambda_c \f$ are the
kiinematic constraint Langrange multipliers. We still require \f$ lambda_m = 0 \f$
but we must allow the kinematic constraints to apply force. Consider a point
mass with degrees of freedom \f$ x \f$ and \f$ y \f$ and generalized forces
\f$ F_x \f$ and \f$ F_y \f$ constrained to the line \f$ y = x \f$ and with
prescribed motion \f$ y(t) = x(t) = sin(t) \f$. Moco will solve for the forces
\f$ F_x \f$ and \f$ F_y \f$ that can achieve this prescribed motion (by setting
\f$ \lambda_m = 0 \f$ and solving for \f$ f_{\mathrm{app}} \f$, and the Lagrange
multiplier \f$ \lambda_c \f$ will ensure that, regardless of the values of \f$
F_x \f$ and \f$ F_y \f$, the mass will remain on the line.


Importantly, the prescribed motion must already obey the kinematic constraints.
MocoInverse attempts to alter your provided kinematics to satisfy the kinematic
constraints, but PositionMotion permits you to prescribe kinematics that
violate the constraints.


@section tips Tips for solving a custom problem

- Add reserve actuators!
- Make sure every variable has bounds.
- If controls display high frequency oscillations, try tightening the solver's
  convergence and constraint tolerances.

*/

/**
@defgroup mococost Available cost terms

These are the available cost terms you can use in your cost functional. If none
of these satisfy your needs, you can define your own using a plugin.
*/

} // namespace OpenSim

